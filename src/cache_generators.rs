use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

use anyhow::Context;
use anyhow::Result;
use tracing::info;

use crate::cache::Cache;
use crate::cache::CacheEntry;
use crate::gatekeeper::get_config_dir;

/// Trait for generating cache files in different formats
pub trait CacheGenerator {
    /// Returns the name/identifier of this cache format
    fn name(&self) -> &'static str;

    /// Returns the file extension for this cache format
    fn file_extension(&self) -> &'static str;

    /// Generates the cache content as a string
    fn generate_content(&self, cache: &Cache) -> Result<String>;

    /// Generates the cache file at the specified path
    fn generate_file(&self, cache: &Cache, cache_path: Option<PathBuf>) -> Result<()> {
        let mut config_dir = get_config_dir()?;
        config_dir.push("cache");
        config_dir.push(format!("cache.{}", self.file_extension()));

        let file_path = cache_path.unwrap_or(config_dir);

        // Create cache directory if it doesn't exist
        if let Some(parent) = file_path.parent() {
            fs::create_dir_all(parent)?;
        }

        let content = self.generate_content(cache)?;

        fs::write(&file_path, content)
            .with_context(|| format!("Failed to write {} cache to {:?}", self.name(), file_path))?;

        info!("Generated {} cache at {:?}", self.name(), file_path);
        Ok(())
    }
}

/// Lua cache generator
pub struct LuaCacheGenerator;

impl CacheGenerator for LuaCacheGenerator {
    fn name(&self) -> &'static str {
        "Lua"
    }

    fn file_extension(&self) -> &'static str {
        "lua"
    }

    fn generate_content(&self, cache: &Cache) -> Result<String> {
        let mut content = String::new();
        content.push_str("-- Auto-generated by dotgk sync\n");
        content.push_str("-- Do not edit manually\n\n");
        content.push_str("local dotgk = {\n");

        // Sort entries by name for consistent output
        let mut entries: Vec<(&String, &CacheEntry)> = cache.cache.iter().collect();
        entries.sort_by(|a, b| a.0.cmp(b.0));

        for (name, entry) in entries {
            content.push_str(&format!("  [\"{}\"] = {},\n", name, entry.value));
        }

        content.push_str("}\n\n");
        content.push_str("return dotgk\n");

        Ok(content)
    }
}

/// Python cache generator
pub struct PythonCacheGenerator;

impl CacheGenerator for PythonCacheGenerator {
    fn name(&self) -> &'static str {
        "python"
    }

    fn file_extension(&self) -> &'static str {
        "py"
    }

    fn generate_content(&self, cache: &Cache) -> Result<String> {
        let mut content = String::new();
        content.push_str("# Auto-generated by dotgk sync\n");
        content.push_str("# Do not edit manually\n\n");
        content.push_str("\"\"\"Dotgk cache for Python.\"\"\"\n\n");

        // Sort entries by name for consistent output
        let mut entries: Vec<(&String, &CacheEntry)> = cache.cache.iter().collect();
        entries.sort_by(|a, b| a.0.cmp(b.0));

        // Generate dictionary
        content.push_str("DOTGK = {\n");
        for (name, entry) in entries {
            let value = if entry.value { "True" } else { "False" };
            content.push_str(&format!("    \"{}\": {},\n", name, value));
        }
        content.push_str("}\n\n");

        // Add helper function
        content.push_str("def check(name: str) -> bool:\n");
        content.push_str("    \"\"\"Check if a gatekeeper is enabled.\"\"\"\n");
        content.push_str("    return DOTGK.get(name, False)\n");

        Ok(content)
    }
}

/// Shell cache generator
pub struct ShellCacheGenerator;

impl CacheGenerator for ShellCacheGenerator {
    fn name(&self) -> &'static str {
        "shell"
    }

    fn file_extension(&self) -> &'static str {
        "sh"
    }

    fn generate_content(&self, cache: &Cache) -> Result<String> {
        let mut content = String::new();
        content.push_str("#!/bin/bash\n");
        content.push_str("# Auto-generated by dotgk sync\n");
        content.push_str("# Do not edit manually\n");
        content.push_str("# Source this file to get gatekeeper variables\n\n");

        // Sort entries by name for consistent output
        let mut entries: Vec<(&String, &CacheEntry)> = cache.cache.iter().collect();
        entries.sort_by(|a, b| a.0.cmp(b.0));

        for (name, entry) in entries {
            // Convert name to valid shell variable name (replace hyphens with underscores, etc.)
            let var_name = name.replace("-", "_").replace(".", "_").to_uppercase();
            let value = if entry.value { "true" } else { "false" };
            content.push_str(&format!("export DOTGK_{}=\"{}\"\n", var_name, value));
        }

        // Add a helper function to check gatekeeper values
        content.push_str("\n# Helper function to check gatekeeper values\n");
        content.push_str("dotgk_check() {\n");
        content.push_str("  local name=\"$1\"\n");
        content.push_str("  local var_name=\"DOTGK_$(echo \"$name\" | tr '[:lower:]' '[:upper:]' | tr '-.' '__')\"\n");
        content.push_str("  local value=\"${!var_name}\"\n");
        content.push_str("  [[ \"$value\" == \"true\" ]]\n");
        content.push_str("}\n");

        Ok(content)
    }
}

/// Registry for managing cache generators
pub struct CacheGeneratorRegistry {
    generators: HashMap<String, Box<dyn CacheGenerator>>,
}

impl CacheGeneratorRegistry {
    /// Create a new registry with default generators
    pub fn new() -> Self {
        let mut registry = Self {
            generators: HashMap::new(),
        };

        // Register built-in generators
        registry.register(Box::new(LuaCacheGenerator));
        registry.register(Box::new(PythonCacheGenerator));
        registry.register(Box::new(ShellCacheGenerator));

        registry
    }

    /// Register a new cache generator
    pub fn register(&mut self, generator: Box<dyn CacheGenerator>) {
        self.generators
            .insert(generator.name().to_string(), generator);
    }

    /// Get a generator by name
    pub fn get(&self, name: &str) -> Option<&dyn CacheGenerator> {
        self.generators.get(name).map(|g| g.as_ref())
    }

    /// Get all available generator names
    pub fn available_generators(&self) -> Vec<&str> {
        self.generators.keys().map(|s| s.as_str()).collect()
    }

    /// Generate cache files for the specified formats
    pub fn generate_caches(&self, cache: &Cache, enabled_formats: &[String]) -> Vec<String> {
        let mut generated_formats = Vec::new();

        for format in enabled_formats {
            if let Some(generator) = self.get(format) {
                if let Err(e) = generator.generate_file(cache, None) {
                    tracing::error!("Failed to generate {} cache: {}", format, e);
                } else {
                    generated_formats.push(format.clone());
                }
            } else {
                tracing::warn!("Unknown cache format requested: {}", format);
            }
        }

        generated_formats
    }
}

impl Default for CacheGeneratorRegistry {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::*;
    use crate::cache::Cache;
    use crate::cache::CacheEntry;
    use crate::cache::UpdateType;

    fn create_test_cache() -> Cache {
        let mut cache_entries = HashMap::new();
        cache_entries.insert(
            "test-gk".to_string(),
            CacheEntry {
                value: true,
                ts: 1000,
                update_type: UpdateType::Sync,
                expires_at: None,
            },
        );
        cache_entries.insert(
            "another_gk".to_string(),
            CacheEntry {
                value: false,
                ts: 1000,
                update_type: UpdateType::Sync,
                expires_at: None,
            },
        );

        Cache {
            cache: cache_entries,
            ts: 1000,
        }
    }

    #[test]
    fn test_lua_generator() -> Result<()> {
        let generator = LuaCacheGenerator;
        let cache = create_test_cache();

        let content = generator.generate_content(&cache)?;

        assert!(content.contains("-- Auto-generated by dotgk sync"));
        assert!(content.contains("local dotgk = {"));
        assert!(content.contains("[\"another_gk\"] = false"));
        assert!(content.contains("[\"test-gk\"] = true"));
        assert!(content.contains("return dotgk"));

        Ok(())
    }

    #[test]
    fn test_python_generator() -> Result<()> {
        let generator = PythonCacheGenerator;
        let cache = create_test_cache();

        let content = generator.generate_content(&cache)?;

        assert!(content.contains("# Auto-generated by dotgk sync"));
        assert!(content.contains("\"\"\"Dotgk cache for Python.\"\"\""));
        assert!(content.contains("DOTGK = {"));
        assert!(content.contains("    \"another_gk\": False,"));
        assert!(content.contains("    \"test-gk\": True,"));
        assert!(content.contains("def check(name: str) -> bool:"));

        Ok(())
    }

    #[test]
    fn test_shell_generator() -> Result<()> {
        let generator = ShellCacheGenerator;
        let cache = create_test_cache();

        let content = generator.generate_content(&cache)?;

        assert!(content.contains("#!/bin/bash"));
        assert!(content.contains("# Auto-generated by dotgk sync"));
        assert!(content.contains("export DOTGK_ANOTHER_GK=\"false\""));
        assert!(content.contains("export DOTGK_TEST_GK=\"true\""));
        assert!(content.contains("dotgk_check() {"));

        Ok(())
    }

    #[test]
    fn test_registry() {
        let registry = CacheGeneratorRegistry::new();

        assert!(registry.get("Lua").is_some());
        assert!(registry.get("shell").is_some());
        assert!(registry.get("nonexistent").is_none());

        let available = registry.available_generators();
        assert!(available.contains(&"Lua"));
        assert!(available.contains(&"shell"));
    }
}
