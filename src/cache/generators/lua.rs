use anyhow::Result;

use crate::cache::cache::Cache;
use crate::cache::cache::CacheEntry;
use crate::cache::generators::CacheGenerator;

/// Lua cache generator
pub struct LuaCacheGenerator;

impl CacheGenerator for LuaCacheGenerator {
    fn name(&self) -> &'static str {
        "lua"
    }

    fn file_extension(&self) -> &'static str {
        "lua"
    }

    fn generate_content(&self, cache: &Cache) -> Result<String> {
        let mut content = String::new();
        content.push_str("-- Auto-generated by dotgk sync\n");
        content.push_str("-- Do not edit manually\n\n");
        content.push_str("local dotgk = {\n");

        // Sort entries by name for consistent output
        let mut entries: Vec<(&String, &CacheEntry)> = cache.cache.iter().collect();
        entries.sort_by(|a, b| a.0.cmp(b.0));

        for (name, entry) in entries {
            content.push_str(&format!("  [\"{}\"] = {},\n", name, entry.value));
        }

        content.push_str("}\n\n");

        // Add helper function
        content.push_str("-- Helper function to check gatekeeper values\n");
        content.push_str("function dotgk.check(name)\n");
        content.push_str("  return dotgk[name] or false\n");
        content.push_str("end\n\n");

        content.push_str("return dotgk\n");

        Ok(content)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cache::generators::test_utils::create_test_cache;

    #[test]
    fn test_lua_generator() -> Result<()> {
        let generator = LuaCacheGenerator;
        let cache = create_test_cache();

        let content = generator.generate_content(&cache)?;

        assert!(content.contains("-- Auto-generated by dotgk sync"));
        assert!(content.contains("local dotgk = {"));
        assert!(content.contains("[\"another_gk\"] = false"));
        assert!(content.contains("[\"test-gk\"] = true"));
        assert!(content.contains("function dotgk.check(name)"));
        assert!(content.contains("return dotgk"));

        Ok(())
    }
}
